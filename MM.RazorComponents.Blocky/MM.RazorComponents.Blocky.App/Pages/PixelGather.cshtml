@page "/p4"
@using SkiaSharp

<div class="container-fluid mb-auto">
    <div class="row">
        <div class="col-12">
            <h3>Pixel image @(Pixels?.Count.ToString("0,000 Pixels"))</h3>
            <input type="file" onchange="var reader = new FileReader(); reader.addEventListener('load', function () { var el = document.querySelector('#filedata'); el.value = this.result; el.dispatchEvent(new Event('change')); }, false); reader.readAsDataURL(this.files[0]);" />
            <input type="text" id="filedata" hidden="hidden" bind="@files" />
        </div>
    </div>
    <div class="row">
        <div class="col-12">
            @if (Pixels is null)
            {
                <h4>Upload an image...keep it small (&lt;25KB) for now or SignalR will break</h4>
                <p>This page uses a small piece of javascript to transfer the file upload to the server.</p>
                <p>Everything else is either C# or CSS.</p>
            }
            else if (IsLoading)
            {
                <h4>Image uploading...</h4>
                <progress max="@PictureHeight" value="@Progress"></progress>
            }
            else
            {
                foreach (var pixel in Pixels)
                {
                    <KeyframePixel Color=pixel.Colors Position=pixel.Position Size=pixel.Size SpeedRange=@SpeedRange />
                }
            }
        </div>
    </div>
</div>
@functions {
  bool IsLoading;
  bool IsRendering;
  int Progress;
  byte[] FileData;
  string files
  {
      get => ""; set
      {
          try
          {
              if (value.Contains(";base64,") && FileData is null)
              {
                  FileData = Convert.FromBase64String(value.Substring(value.IndexOf("base64") + 7));
              }
          }
          catch { }
          Loader = LoadImage();
      }
  }

  // The list of active pixels
  System.Collections.Concurrent.ConcurrentBag<PixelDTO> Pixels;

  double MAXDIM = 100;
  public int PixelSize = 4;
  public int PictureWidth = 0;
  public int PictureHeight = 0;
  public Vector2D SpeedRange = new Vector2D(2000, 3000);
  Task Loader;

  async Task LoadImage()
  {
      IsLoading = true;
      Progress = 0;
      await Task.Delay(1);
      var bytes = FileData;
      using (var stream = new SKMemoryStream(bytes))
      {
          using (SKBitmap imageInitial = SKBitmap.Decode(stream))
          {
              Pixels = new System.Collections.Concurrent.ConcurrentBag<PixelDTO>();
              await Invoke(StateHasChanged);
              await Task.Delay(1);
              int newSize = (int)MAXDIM;
              SKBitmap image;
              if (imageInitial.Width > newSize || imageInitial.Height > newSize)
              {
                  var newWidth = imageInitial.Width;
                  var newHeight = imageInitial.Height;
                  double scale = 1;
                  if (newWidth > newHeight)
                  {
                      scale = (newSize / (double)newWidth);
                  }
                  else
                  {
                      scale = (newSize / (double)newHeight);
                  }
                  var newInfo = imageInitial.Info.WithSize((int)(newWidth * scale), (int)(newHeight * scale));
                  image = imageInitial.Resize(newInfo, SKFilterQuality.High);
              }
              else
              {
                  image = imageInitial;
              }

              PictureHeight = image.Height;
              PictureWidth = image.Width;
              System.Diagnostics.Stopwatch stopWatch = new System.Diagnostics.Stopwatch();
              stopWatch.Start();
              Console.WriteLine($"Starting pixel generation");
              for (int y = 0; y < image.Height; y++)
              {
                  Parallel.For(0, image.Width - 1, x =>
                  {
                      SKColor sKColor = image.GetPixel(x, y);
                      sKColor.ToHsl(out float h, out float s, out float l);
                      if (l < 100)
                      {
                          var pixel = new PixelDTO()
                          {
                              Colors = new Colors(h, s, l, sKColor.Alpha),
                              Position = new Vector2D(x * PixelSize, y * PixelSize),
                              Scale = PixelSize
                          };
                          Pixels.Add(pixel);
                      }
                  });
                  Progress++;
                  await Invoke(StateHasChanged);
                  await Task.Delay(1);
              };
              stopWatch.Stop();
              Console.WriteLine($"Finished pixel generation {stopWatch.Elapsed}");
          }
      }
      IsRendering = false;
      FileData = null;
      IsLoading = false;
      await Invoke(StateHasChanged);
      await Task.Delay(0);
  }

}
